# Тестовое задание
Тут будут краткие и не очень ответы на вопросы тествого, в main.rs будет более подробно описан ход решения и мысли

## Задание 1
Функция example1 зависает потому что используется корутина с бесконечным циклом, которая блокирует поток, а корутине для записи нет потока где она могла бы записать данные в канал.

Для исправления зависания можно:
- увеличить кол-во потоков до 2ух
- поменять порядок вызова spawn для корутин(сначала запустить корутину на запись, потом на чтение)
- заменить ```try_recv``` на ```recv().await```


## Задание 2

Я бы сказал что это UB, ведь указатель t2.ptr указывает на место где хранилось t1.value,
но из-за того что это все происходит в рамках стека функции и
какие-то изменения по этому адресу произойдут только после выходны из функции, скоре всего вывод будет 64, потому что это последние значение t1.value

## Задание 3 

Расмотрим каждый из примеров заполнения вектора

### v1

```rust
    let start_time = std::time::Instant::now();
    let mut my_vec1 = Vec::new(); // Создаем векора нулевого размера
    for i in 0u64..capacity {
        my_vec1.insert(i as usize, i); // Каждый раз когда len == capacity будет перевыделение памяти 
    }
    println!(
        "execution time {}",
        (std::time::Instant::now() - start_time).as_nanos()
    );
```

Самый плохой вариант заполнения длинного вектора, хоть и вставка в конец вектора О(1), в случае если длина вектора 
упрется в размер выделенной памяти, будет происходит выделение новой памяти и копирование всех уже существующих элементов O(N).

### v2
```rust
    let start_time = std::time::Instant::now();
    let mut my_vec2 = Vec::with_capacity(capacity as usize);
    for i in 0u64..capacity {
        my_vec2.insert(i as usize, i);
    }
    println!(
        "execution time {}",
        (std::time::Instant::now() - start_time).as_nanos()
    );
```

Этот вариант лучше чем предыдущий тем что мы зарание выделяем нужную память в куче, и в процессе заполнения вектора перевыделений не будет.

### v3

```rust
    let start_time = std::time::Instant::now();
    let mut my_vec3 = vec![6u64; capacity as usize];
    println!(
        "execution time {}",
        (std::time::Instant::now() - start_time).as_nanos()
    );
```

Отличный вариант для создания проинициализированного вектора с фиксированным размером. Память для ветктора будет выделена за 1 раз и проинициазированна эффективным способом через memset.

### v4

```rust
    let start_time = std::time::Instant::now();
    for mut elem in my_vec3 {
        elem = 7u64;
    }
    println!(
        "execution time {}",
        (std::time::Instant::now() - start_time).as_nanos()
    );
```

Тут я мучаюсь в догадках про что этот пример, про сравнение с функцией ```insert``` или про сравнение с v5? Расмотрим тут вариант сравнение с ```insert```.

Простое заполнение уже проиницизированного вектора сильно легковестнее, чем заполенение вектора через ```insert``` потому что там происходят доп проверки для выхода за граници массива для допполнительных аллокаций итд.

Сравнение с v5 в пункте про v5.

### v5

```rust
    let start_time = std::time::Instant::now();
    let my_vec4 = vec![0u64; capacity as usize];
    println!(
        "execution time {}",
        (std::time::Instant::now() - start_time).as_nanos()
    );
```

Тут результат меня, конечно, убил. Признаюсь пришлось гуглить, не знал о таком.
Как оказалось тут операционная система при запросе памяти проинициализрованной ```0```, может мапить эту память на специально заранее подготовленную так называемую zero pages - куски памяти которые всегда заполнена нулями.

Тут я если честно не доконца разобрался, но как понял. ОС выделяет память(не проинициализированна, заполененая мусором)
и каким-то хитрым образом мапит ее на zero pages, после чего при попытке читать из нее, она в реальности будет читаться из zero pages, а при попытке записи будет происходить прервыание, которые разорвет маппинг и честно проинициализрует страницу в выделенной памяти, CoW какой-то.

Тогда если вернуться к v4, все эти прервывание и инициализации памяти должны вызывать некоторые накладные расходы в сравнении с простым заполенением уже проинициализированного вектора, хотя локально я такого не заметил, но возможно компилятор тут наоптимизировал это все записи как deadcode

## Задание 4
Контекст: на двух потоках вызываются 3 корутины, которые конкурируют за 1 ресурс.

### example4_async_mutex
Используется асинхронный мьютекс при вызове lock, по сути дела создает новую корутину ожидания освобождения ресурса
и захвата его, это будет вызывать некоторые дополнительные накладыне расходы на работу шедулера tokio, который будет жанглировать между 3мя корутинами. Но зато потоки не будут заблокированны.

### example4_std_mutex
Используется синхронный(блокирующий) мьютекс, который при вызове lock будет блокировать поток. Кажется это конкретно в этой задачке, вызывает сильно меньше свистопляски с шедулером, поэтому и работает быстрее, но потоки заблокированны

## Задание 5
### В чем ошибка дизайна?

```rust
    pub struct Triangle {
        pub a: (f32, f32), //! 
        pub b: (f32, f32),
        pub c: (f32, f32),
        area: Option<f32>, //!
        perimeter: Option<f32>, //!
    }
```
```(f32, f32)``` - кажется тут прибиваться гвоздями к таком типу точки, не самое лучшее решение, лучше бы завязаться на какой-нибудь ```trait Point2d``` и структуру сделать с шаблонным аргументом.

```area: Option<f32>``` и ```perimeter: Option<f32>``` -  вызывают прям очень много вопросов, при сомнительнной ценности. Если мы хотим лениво кешировать значения площади и периметра, то нужно задуматься и о инвалидации этого кеша, чего в примере нету, и например такой код, будет гарантированно давать такую ошибку
```rust
{
    let mut t = Triangle::new();
    
    t.a = (0f32, 0f32);
    t.b = (0f32, 1f32);
    t.c = (1f32, 0f32);
    let area = t.area();
    t.b = (0f32, 2f32);
    assert!(area == t.area()) //! хотя должно быть !=
}
```
Я бы отказался от хранения такого кеша, и если бы нужно было бы прям специально что-то кешировать, то сделал б это точно не в этой структуре, а где-то сбоку, что сохранить <i><b>S</i></b>OLID

Идем дальше к разбору ```impl Triangle```

```rust
fn dist(a: (f32, f32), b: (f32, f32)) -> f32;
```
Мне кажется, что функция dist слабо связанно с треугольниками, больше похоже что принадлежит точкам или должна стать свободной функцией. я бы вынес ее куда-то из импл блока треугольника.

```rust
pub fn perimeter(&mut self) -> f32;
pub fn area(&mut self) -> f32;
```
Обе функции perimeter и area имеют более широкий смысл чем только площадь и периметр треугольника, я их тоже бы вынес из этого блока, как-то так, по растовому
```rust
pub trait Perimeter {
    fn perimeter(&self) -> f32;
}
pub trait Area {
    fn area(&self) -> f32;
}
```

и соотвественнно реализовал их для структуры треугольника, позволит иметь общие интерфейсы для треугольника и квадрата например.

Функция new, а комментарий это требование?

```rust
//new makes no guarantee for a specific values of a,b,c,area,perimeter at initialization
pub fn new() -> Triangle {
    Triangle {
        a: (0f32, 0f32),
        b: (0f32, 0f32),
        c: (0f32, 0f32),
        area: None,
        perimeter: None,
    }
}
```
если требование и мы хотим создавать вырожденные треугольники, то эта функция по ее телу, больше похожа на Default::default(), я бы убрал new и сделал реализацию трейта Default, к тому же тут кажется можно обойстись ```#[derive(Default)]```

Но вообще имхо интерфейсы для создание не валидных объектов под new и default это кажется не rust-like подход я бы предложил такой вариант
```rust
impl Triangle {
    pub fn new(a: (f32, f32), b: (f32, f32), c: (f32, f32)) -> Option<Self> {
        // сделать проверки на существование треугольника по таким точкам
        // вернуть None если не удовлетворяет
        Some(Self::new_unchecked(a, b, c))
    }
    
    pub fn new_unchecked(a: (f32, f32), b: (f32, f32), c: (f32, f32)) -> Self {
        Self {a, b, c, arec: None, perimeter: None}
    }
}
```
Таким образом получим и вариант с соблюдением инвариантов треугольника и с нарушением этих инвариантов. Ну и докучи накинуть Default если хочется иметь шорткат для создания невалидных треугольников
```rust
impl Default for Triangle {
    fn default() -> Self {
        Self::new_unchecked((0f32, 0f32), (0f32, 0f32), (0f32, 0f32))
    }
}
```

Набросал реализацию с учетом всех замечаний в ```mod example5_fixed```

### Каких тестов не хватает?
Я бы добавил еще тестов на проверку треугольников отрицательными числами для треугольников

### Есть ли лишние тесты?

в тесте ```fn test_area()``` есть проверка
```rust
let mut t = Triangle::new();

t.a = (0f32, 0f32);
t.b = (0f32, 1000f32);
t.c = (1000f32, 0f32);

println!("{}",t.area());
```
Ну это не то чтобы лишний тест, это просто не тест

набросал тесты в ```mod example5_fixed_test``` 

